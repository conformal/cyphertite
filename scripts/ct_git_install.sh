#!/bin/sh
#
# Copyright (c) 2011 Conformal Systems LLC <info@conformal.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# This is a convenience script to automatically update cyphertite and all of
# its Conformal dependencies from the official source repositories, build them,
# and install them in the correct order.
#
# This script must be compatible with ksh, bash, and csh.  Take care when
# editing it.

report_err_header()
{
	echo "***********" 1>&2
	echo "** ERROR **" 1>&2
	echo "***********" 1>&2
}

report_err()
{
	report_err_header
	echo -e "$1" 1>&2
	exit 1
}

report_util_err()
{
	report_err_header
	echo "Unable to find '$1' utility.  Install the utility or" 1>&2
	echo "ensure the directory where it resides in the system PATH." 1>&2
	exit 1
}

check_root_perms()
{
	if [ "$(id -u)" != "0" ]; then
		ERRMSG="This script must be run as root.  Try sudo $0"
		report_err "$ERRMSG"
	fi
}

check_utils()
{
	# check for presence of utilities used by script
	UTILS_USED="cut gcc git grep head install make mkdir rm sed tar uname tar"
	for util in $UTILS_USED; do
		type $util >/dev/null 2>&1 || report_util_err "$util"
	done


	#  choose which ftp tool to use - wget by default
	OS=$(uname)
	DOWNLOAD_TOOL="wget"
	if [ "$OS" = "OpenBSD" ]; then
		DOWNLOAD_TOOL="ftp"
	elif [ "$OS" = "FreeBSD" ]; then
		DOWNLOAD_TOOL="fetch"
	fi
	type $DOWNLOAD_TOOL >/dev/null 2>&1 || report_util_err "$DOWNLOAD_TOOL"
}

check_external_libs()
{
	EXTERNAL_LIBS="expat z lzo2 lzma sqlite3 event_core edit ncurses"

	# standard lib dirs - override below if needed
	SLIB_DIRS="/usr/lib /usr/lib64 /usr/local/lib /usr/local/lib64 /usr/local/lib/event2"

	# attempt to extract lib dirs from ld
	LIB_DIRS=$(ld --verbose 2>/dev/null | grep SEARCH_DIR)
	LIB_DIRS=$(echo $LIB_DIRS | sed -e 's/SEARCH_DIR("//g')
	LIB_DIRS=$(echo $LIB_DIRS | sed -e 's/=//g')
	LIB_DIRS=$(echo $LIB_DIRS | sed -e 's/");//g')

	# fallback to standard lib dirs - override below if needed
	for d in $SLIB_DIRS; do
	    IGNORE=$(echo "$LIB_DIRS" | grep "$d" 2>/dev/null)
	    if [ $? -ne 0 ]; then
		LIB_DIRS="$LIB_DIRS $d"
	    fi
	done

	# linux flavor
	if [ "$OS" = "Linux" ]; then
		EXTRA_LIBS="bsd"
		LIB_EXTS="a so"
	# bsd flavor
	elif echo "$OS" | grep "BSD" >/dev/null 2>&1; then
		EXTRA_LIBS="ssl crypto"
		LIB_EXTS="a so.*"
	fi


	# allow extra libs depending on os
	[ -n "$EXTRA_LIBS" ] && EXTERNAL_LIBS="$EXTERNAL_LIBS $EXTRA_LIBS"

	# find missing libs
	MISSING_LIBS=""
	for lib in $EXTERNAL_LIBS; do
		LIB_FOUND=0
		for d in $LIB_DIRS; do
			for ext in $LIB_EXTS; do
				LIB_FILES="$d/lib$lib."$ext
				for f in $LIB_FILES; do
					if [ -e "$f" ]; then
						LIB_FOUND=1
					fi
				done
			done
		done
		if [ $LIB_FOUND -eq 0 ]; then
			MISSING_LIBS="$MISSING_LIBS * $lib\n "
		fi
	done
	if [ -n "$MISSING_LIBS" ]; then
		ERRMSG="Unable to find the following required external libraries:\n"
		ERRMSG="$ERRMSG $MISSING_LIBS"
		report_err "$ERRMSG"
	fi
}

ct_download_url()
{
	# use the correct syntax depending on the native download tool
	DOWNLOAD_NAME=$1
	DOWNLOAD_URL=$2
	if [ "$DOWNLOAD_TOOL" = "wget" ]; then
		"$DOWNLOAD_TOOL" "$DOWNLOAD_URL"
	elif [ "$DOWNLOAD_TOOL" = "fetch" ]; then
		"$DOWNLOAD_TOOL" "$DOWNLOAD_URL"
	elif [ "$DOWNLOAD_TOOL" = "ftp" ]; then
		"$DOWNLOAD_TOOL" -o "$DOWNLOAD_NAME" "$DOWNLOAD_URL"
	fi
}

ct_get_source()
{
	# create directory to house all source if needed
	CT_SRC_DIR="ct_src"
	if [ ! -d "$CT_SRC_DIR" ]; then
		mkdir "$CT_SRC_DIR" || report_err "Unable to create '$CT_SRC_DIR'."
	fi
	cd "$CT_SRC_DIR"

	# download the openssl source tar if needed
	if ! openssl ciphers | grep ECDSA >/dev/null 2>&1; then
		OPENSSL_PKG="openssl-1.0.1g"
		OPENSSL_TGZ="$OPENSSL_PKG.tar.gz"
		OPENSSL_URL="https://www.cyphertite.com/snapshots/OpenSSL/$OPENSSL_TGZ"
		if [ ! -d "$OPENSSL_PKG" ]; then
			if [ ! -e "$OPENSSL_TGZ" ]; then
				echo "Getting source ==> $OPENSSL_PKG"
				ct_download_url "$OPENSSL_TGZ" "$OPENSSL_URL"
			fi
			tar -zxf "$OPENSSL_TGZ"
		fi
		openssl_ver="OpenSSL/1.0.1g"
        else
		openssl_ver=$(openssl version | sed -e "s/ /\//" |cut -d"-" -f1)
                echo "Found $openssl_ver, skipping build"

        fi

	# download the curl source tar
        if ! curl --version | grep $openssl_ver >/dev/null 2>&1; then
		CURL_PKG="curl-7.28.1"
		CURL_TGZ="$CURL_PKG.tar.gz"
		CURL_URL="https://www.cyphertite.com/snapshots/curl/$CURL_TGZ"
		if [ ! -d "$CURL_PKG" ]; then
			if [ ! -e "$CURL_TGZ" ]; then
				echo "Getting source ==> $CURL_PKG"
				ct_download_url "$CURL_TGZ" "$CURL_URL"
			fi
				tar -zxf "$CURL_TGZ"
		fi
        else
		curl_ver=$(curl --version |cut -d" " -f1,2 |head -1)
		echo "Found $curl_ver, skipping build"
        fi

	# clone the source or update existing repo for ct and all of its
	# Conformal dependencies
	CT_PKGS="clens clog assl xmlsd shrink exude cyphertite"
	for pkg in $CT_PKGS; do
		if [ ! -d "$pkg" ]; then
			echo "Getting source ==> $pkg"
			git clone https://opensource.conformal.com/git/$pkg.git ||
			    report_err "Unable to get source for '$pkg'."
		else
			echo "Updating source ==> $pkg"
			cd "$pkg"
			git pull || report_err "Unable to update source for '$pkg'."
			echo "Cleaning ==> $pkg"
			make clean || report_err "Make clean failed for '$pkg'."
			cd ..
		fi
	done
}

ct_build_and_install()
{
	# build and install openssl source with ECDSA if base system package
	# doesn't have it.
	pkg="$OPENSSL_PKG"
	if ! openssl ciphers | grep ECDSA >/dev/null 2>&1; then
		echo "Building ==> $pkg"
		cd "$pkg"
		./config || report_err "config script failed for '$pkg'."
		make || report_err "Make failed for '$pkg'."
		echo "Installing ==> $pkg"
		make install || report_err "Install failed for '$pkg'."
		cd ..
	fi

	# build and install curl source using the same openssl version as ct.
	pkg="$CURL_PKG"
        if ! curl --version | grep $openssl_ver >/dev/null 2>&1; then
		echo "Building ==> $pkg"
		cd "$pkg"
		./configure --disable-shared --disable-ldap --with-ssl || \
		    report_err "config script failed for '$pkg'."
		make || report_err "Make failed for '$pkg'."
		echo "Installing ==> $pkg"
		make install || report_err "Install failed for '$pkg'."
		cd ..
        else
		curl_ver=$(curl --version |cut -d" " -f1,2 |head -1)
		echo "Found $curl_ver, skipping build"
        fi

	# build and install packages in dependency order
	CT_PKGS="clens clog assl xmlsd shrink exude cyphertite"
	for pkg in $CT_PKGS; do
		echo "Building ==> $pkg"
		cd "$pkg"
		make obj || report_err "Unable to make obj directory for '$pkg'."
		make depend || report_err "Unable to make dependencies for '$pkg'."
		make || report_err "Make failed for '$pkg'."
		echo "Installing ==> $pkg"
		make install || report_err "Install failed for '$pkg'."
		cd ..
	done
}


# main execution starts here
check_root_perms
check_utils
check_external_libs
ct_get_source
ct_build_and_install

